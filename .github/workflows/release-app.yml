name: release-app

on:
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g. v1.0.0)"
        required: false

jobs:
  build:
    runs-on: macos-15
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Select Xcode 26.2 (Swift 6.2)
        run: sudo xcode-select -s /Applications/Xcode_26.2.app/Contents/Developer

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.tag }}" ]; then
            echo "tag=${{ github.event.inputs.tag }}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=${GITHUB_REF#refs/tags/}" >> "$GITHUB_OUTPUT"
          fi

      - name: Import signing certificate
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.CERTIFICATE_P12_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode > /tmp/certificate.p12

          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security import /tmp/certificate.p12 \
            -P "$CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          security set-key-partition-list \
            -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" \
            "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

          rm -f /tmp/certificate.p12

      - name: Build, sign, and package
        env:
          VERSION: ${{ steps.version.outputs.tag }}
          CODESIGN_ENABLED: "1"
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: bash scripts/build/package-app.sh

      - name: Cleanup keychain
        if: always()
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH"
          fi

      - name: Determine release type
        id: release_type
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          
          # 判断是否 pre-release (包含 beta, alpha, rc 的 tag)
          PRERELEASE="false"
          if [[ "$TAG" =~ -(beta|alpha|rc)\.[0-9]+$ ]]; then
            PRERELEASE="true"
            echo "Detected pre-release tag: $TAG"
          fi
          
          echo "is_prerelease=$PRERELEASE" >> "$GITHUB_OUTPUT"
          echo "Release type: $PRERELEASE (tag: $TAG)"

      - name: Install Sparkle tools
        run: |
          # Download Sparkle release to get sign_update tool
          SPARKLE_VERSION="2.6.4"
          curl -L -o /tmp/Sparkle.tar.xz "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"
          tar -xf /tmp/Sparkle.tar.xz -C /tmp
          cp /tmp/bin/sign_update /usr/local/bin/sign_update
          cp /tmp/bin/generate_appcast /usr/local/bin/generate_appcast
          chmod +x /usr/local/bin/sign_update /usr/local/bin/generate_appcast

      - name: Sign release with Sparkle
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          DMG_PATH="dist/VibeBar-${TAG#v}-universal.dmg"

          # Create EdDSA signature (using stdin for security)
          SIGNATURE=$(echo "$SPARKLE_PRIVATE_KEY" | sign_update --ed-key-file - "$DMG_PATH")
          echo "Sparkle signature: $SIGNATURE"
          echo "$SIGNATURE" > "${DMG_PATH}.sparkle-signature"

      - name: Update appcast.xml
        id: update_appcast
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          DMG_PATH="dist/VibeBar-${TAG#v}-universal.dmg"
          VERSION="${TAG#v}"

          # Get file size
          FILE_SIZE=$(stat -f%z "$DMG_PATH")

          # Get signature
          SIGNATURE=$(cat "${DMG_PATH}.sparkle-signature")

          # Get version number for sparkle:version (numeric only, e.g., 1.3.0-beta.6 -> 13006)
          SPARKLE_VERSION=$(echo "$VERSION" | sed -E 's/([0-9]+)\.([0-9]+)\.([0-9]+).*/\1\2\3/; s/^0*//')
          if [[ "$VERSION" =~ -(beta|alpha|rc)\.?([0-9]+) ]]; then
            PRERELEASE_NUM="${BASH_REMATCH[2]:-0}"
            SPARKLE_VERSION="${SPARKLE_VERSION}$(printf "%02d" "$PRERELEASE_NUM")"
          fi
          SPARKLE_VERSION=${SPARKLE_VERSION:-1}

          # Determine if beta
          IS_BETA="false"
          if [[ "$TAG" =~ -(beta|alpha|rc) ]]; then
            IS_BETA="true"
          fi

          # Update appropriate appcast
          if [ "$IS_BETA" == "true" ]; then
            APPCAST_FILE="docs/appcast-beta.xml"
          else
            APPCAST_FILE="docs/appcast.xml"
          fi

          echo "Updating $APPCAST_FILE for version $VERSION (sparkle:version=$SPARKLE_VERSION)"

          # Use Python to safely modify XML
          python3 << PYTHON_SCRIPT
          import xml.etree.ElementTree as ET
          import re
          from datetime import datetime

          # Register Sparkle namespace
          ET.register_namespace('sparkle', 'http://www.andymatuschak.org/xml-namespaces/sparkle')

          # Parse XML
          tree = ET.parse('$APPCAST_FILE')
          root = tree.getroot()
          channel = root.find('channel')

          # Check if version already exists
          existing = False
          for item in channel.findall('item'):
              version_elem = item.find('{http://www.andymatuschak.org/xml-namespaces/sparkle}version')
              if version_elem is not None and version_elem.text == '$SPARKLE_VERSION':
                  print(f"Version $SPARKLE_VERSION already exists in appcast, skipping")
                  existing = True
                  break

          if existing:
              exit(0)

          # Create new item
          item = ET.Element('item')

          title = ET.SubElement(item, 'title')
          title.text = f'Version $VERSION'

          pubDate = ET.SubElement(item, 'pubDate')
          pubDate.text = datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S +0000')

          sparkle_version = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}version')
          sparkle_version.text = '$SPARKLE_VERSION'

          sparkle_short = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}shortVersionString')
          sparkle_short.text = '$VERSION'

          sparkle_min = ET.SubElement(item, '{http://www.andymatuschak.org/xml-namespaces/sparkle}minimumSystemVersion')
          sparkle_min.text = '13.0'

          description = ET.SubElement(item, 'description')
          # Get changelog from git tag annotation
          description.text = f'<h2>VibeBar $VERSION</h2><ul><li>Version $VERSION release</li></ul>'

          enclosure = ET.SubElement(item, 'enclosure')
          enclosure.set('url', 'https://github.com/yelog/VibeBar/releases/download/$TAG/VibeBar-$VERSION-universal.dmg')
          enclosure.set('length', '$FILE_SIZE')
          enclosure.set('type', 'application/octet-stream')
          # Parse signature format: sparkle:edSignature="..." length="..."
          sig_parts = '$SIGNATURE'.split()
          for part in sig_parts:
              if '=' in part:
                  key, val = part.split('=', 1)
                  if val.startswith('"') and val.endswith('"'):
                      val = val[1:-1]
                  enclosure.set(key, val)

          # Insert after <!-- Latest beta release --> or <!-- Latest stable release --> comment
          comment_found = False
          for i, child in enumerate(channel):
              if isinstance(child, ET.Element):
                  # Check if previous sibling is a comment
                  if i > 0:
                      prev = channel[i-1]
                      if hasattr(prev, 'tag') and prev.tag is ET.Comment:
                          comment_text = str(prev).lower()
                          if 'latest' in comment_text and ('beta' in comment_text or 'stable' in comment_text or 'release' in comment_text):
                              channel.insert(i, item)
                              comment_found = True
                              break

          if not comment_found:
              # Insert as second item (after title/link/description/language)
              insert_pos = 4  # After title, link, description, language
              channel.insert(insert_pos, item)

          # Write back with proper formatting
          tree.write('$APPCAST_FILE', encoding='UTF-8', xml_declaration=True)

          # Pretty print the result
          with open('$APPCAST_FILE', 'r') as f:
              content = f.read()

          # Add proper indentation
          content = re.sub(r'><item>', '>\n        <item>', content)
          content = re.sub(r'></item>', '>\n        </item>', content)
          content = re.sub(r'><title>', '>\n            <title>', content)
          content = re.sub(r'></title>', '</title>', content)
          content = re.sub(r'><pubDate>', '>\n            <pubDate>', content)
          content = re.sub(r'><sparkle:', '>\n            <sparkle:', content)
          content = re.sub(r'><description>', '>\n            <description>', content)
          content = re.sub(r'><enclosure', '>\n            <enclosure', content)
          content = re.sub(r'/></enclosure>', '/>\n        </enclosure>', content)
          content = re.sub(r'/></channel>', '/>\n    </channel>', content)
          content = re.sub(r'</channel></rss>', '</channel>\n</rss>', content)

          with open('$APPCAST_FILE', 'w') as f:
              f.write(content)

          print(f"Successfully added version $VERSION to $APPCAST_FILE")
          PYTHON_SCRIPT

          # Set output for commit step
          echo "appcast_file=$APPCAST_FILE" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Commit and push appcast changes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Stash the appcast changes
          git stash push -m "appcast update"

          # Fetch main branch since we're in detached HEAD (tag push)
          git fetch origin main
          git checkout -B main origin/main

          # Apply stashed changes (prefer ours only if conflict occurs)
          if ! git stash pop; then
            git checkout --ours docs/appcast-beta.xml docs/appcast.xml
            git add docs/appcast-beta.xml docs/appcast.xml
          fi

          git add ${{ steps.update_appcast.outputs.appcast_file }}

          if git diff --cached --quiet; then
            echo "No changes to commit (appcast already up to date)"
          else
            git commit -m "chore(appcast): add ${{ steps.update_appcast.outputs.version }} release entry [skip ci]"
            git push origin main
            echo "Appcast updated and pushed to main"
          fi

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          DMG_PATH="dist/VibeBar-${TAG#v}-universal.dmg"
          SHA_PATH="${DMG_PATH}.sha256"

          PRERELEASE_FLAG=""
          if [ "${{ steps.release_type.outputs.is_prerelease }}" == "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          gh release create "$TAG" \
            --title "$TAG" \
            --generate-notes \
            $PRERELEASE_FLAG \
            "$DMG_PATH" \
            "$SHA_PATH"
